// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies

part of 'initial_navigator.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

/// @nodoc
class _$InitialNavigatorEventTearOff {
  const _$InitialNavigatorEventTearOff();

// ignore: unused_element
  InitInitialNavigatorEvent init() {
    return const InitInitialNavigatorEvent();
  }
}

/// @nodoc
// ignore: unused_element
const $InitialNavigatorEvent = _$InitialNavigatorEventTearOff();

/// @nodoc
mixin _$InitialNavigatorEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult init(),
  });
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult init(),
    @required TResult orElse(),
  });
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult init(InitInitialNavigatorEvent value),
  });
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult init(InitInitialNavigatorEvent value),
    @required TResult orElse(),
  });
}

/// @nodoc
abstract class $InitialNavigatorEventCopyWith<$Res> {
  factory $InitialNavigatorEventCopyWith(InitialNavigatorEvent value,
          $Res Function(InitialNavigatorEvent) then) =
      _$InitialNavigatorEventCopyWithImpl<$Res>;
}

/// @nodoc
class _$InitialNavigatorEventCopyWithImpl<$Res>
    implements $InitialNavigatorEventCopyWith<$Res> {
  _$InitialNavigatorEventCopyWithImpl(this._value, this._then);

  final InitialNavigatorEvent _value;
  // ignore: unused_field
  final $Res Function(InitialNavigatorEvent) _then;
}

/// @nodoc
abstract class $InitInitialNavigatorEventCopyWith<$Res> {
  factory $InitInitialNavigatorEventCopyWith(InitInitialNavigatorEvent value,
          $Res Function(InitInitialNavigatorEvent) then) =
      _$InitInitialNavigatorEventCopyWithImpl<$Res>;
}

/// @nodoc
class _$InitInitialNavigatorEventCopyWithImpl<$Res>
    extends _$InitialNavigatorEventCopyWithImpl<$Res>
    implements $InitInitialNavigatorEventCopyWith<$Res> {
  _$InitInitialNavigatorEventCopyWithImpl(InitInitialNavigatorEvent _value,
      $Res Function(InitInitialNavigatorEvent) _then)
      : super(_value, (v) => _then(v as InitInitialNavigatorEvent));

  @override
  InitInitialNavigatorEvent get _value =>
      super._value as InitInitialNavigatorEvent;
}

/// @nodoc
class _$InitInitialNavigatorEvent extends InitInitialNavigatorEvent {
  const _$InitInitialNavigatorEvent() : super._();

  @override
  String toString() {
    return 'InitialNavigatorEvent.init()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is InitInitialNavigatorEvent);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult init(),
  }) {
    assert(init != null);
    return init();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult init(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (init != null) {
      return init();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult init(InitInitialNavigatorEvent value),
  }) {
    assert(init != null);
    return init(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult init(InitInitialNavigatorEvent value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (init != null) {
      return init(this);
    }
    return orElse();
  }
}

abstract class InitInitialNavigatorEvent extends InitialNavigatorEvent {
  const InitInitialNavigatorEvent._() : super._();
  const factory InitInitialNavigatorEvent() = _$InitInitialNavigatorEvent;
}

/// @nodoc
class _$InitialNavigatorStateTearOff {
  const _$InitialNavigatorStateTearOff();

// ignore: unused_element
  PrimaryInitialNavigatorState primary() {
    return const PrimaryInitialNavigatorState();
  }

// ignore: unused_element
  AuthorizedInitialNavigatorState authorized() {
    return const AuthorizedInitialNavigatorState();
  }

// ignore: unused_element
  UnAuthorizedInitialNavigatorState unAuthorized() {
    return const UnAuthorizedInitialNavigatorState();
  }
}

/// @nodoc
// ignore: unused_element
const $InitialNavigatorState = _$InitialNavigatorStateTearOff();

/// @nodoc
mixin _$InitialNavigatorState {
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult primary(),
    @required TResult authorized(),
    @required TResult unAuthorized(),
  });
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult primary(),
    TResult authorized(),
    TResult unAuthorized(),
    @required TResult orElse(),
  });
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult primary(PrimaryInitialNavigatorState value),
    @required TResult authorized(AuthorizedInitialNavigatorState value),
    @required TResult unAuthorized(UnAuthorizedInitialNavigatorState value),
  });
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult primary(PrimaryInitialNavigatorState value),
    TResult authorized(AuthorizedInitialNavigatorState value),
    TResult unAuthorized(UnAuthorizedInitialNavigatorState value),
    @required TResult orElse(),
  });
}

/// @nodoc
abstract class $InitialNavigatorStateCopyWith<$Res> {
  factory $InitialNavigatorStateCopyWith(InitialNavigatorState value,
          $Res Function(InitialNavigatorState) then) =
      _$InitialNavigatorStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$InitialNavigatorStateCopyWithImpl<$Res>
    implements $InitialNavigatorStateCopyWith<$Res> {
  _$InitialNavigatorStateCopyWithImpl(this._value, this._then);

  final InitialNavigatorState _value;
  // ignore: unused_field
  final $Res Function(InitialNavigatorState) _then;
}

/// @nodoc
abstract class $PrimaryInitialNavigatorStateCopyWith<$Res> {
  factory $PrimaryInitialNavigatorStateCopyWith(
          PrimaryInitialNavigatorState value,
          $Res Function(PrimaryInitialNavigatorState) then) =
      _$PrimaryInitialNavigatorStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$PrimaryInitialNavigatorStateCopyWithImpl<$Res>
    extends _$InitialNavigatorStateCopyWithImpl<$Res>
    implements $PrimaryInitialNavigatorStateCopyWith<$Res> {
  _$PrimaryInitialNavigatorStateCopyWithImpl(
      PrimaryInitialNavigatorState _value,
      $Res Function(PrimaryInitialNavigatorState) _then)
      : super(_value, (v) => _then(v as PrimaryInitialNavigatorState));

  @override
  PrimaryInitialNavigatorState get _value =>
      super._value as PrimaryInitialNavigatorState;
}

/// @nodoc
class _$PrimaryInitialNavigatorState extends PrimaryInitialNavigatorState {
  const _$PrimaryInitialNavigatorState() : super._();

  @override
  String toString() {
    return 'InitialNavigatorState.primary()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is PrimaryInitialNavigatorState);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult primary(),
    @required TResult authorized(),
    @required TResult unAuthorized(),
  }) {
    assert(primary != null);
    assert(authorized != null);
    assert(unAuthorized != null);
    return primary();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult primary(),
    TResult authorized(),
    TResult unAuthorized(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (primary != null) {
      return primary();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult primary(PrimaryInitialNavigatorState value),
    @required TResult authorized(AuthorizedInitialNavigatorState value),
    @required TResult unAuthorized(UnAuthorizedInitialNavigatorState value),
  }) {
    assert(primary != null);
    assert(authorized != null);
    assert(unAuthorized != null);
    return primary(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult primary(PrimaryInitialNavigatorState value),
    TResult authorized(AuthorizedInitialNavigatorState value),
    TResult unAuthorized(UnAuthorizedInitialNavigatorState value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (primary != null) {
      return primary(this);
    }
    return orElse();
  }
}

abstract class PrimaryInitialNavigatorState extends InitialNavigatorState {
  const PrimaryInitialNavigatorState._() : super._();
  const factory PrimaryInitialNavigatorState() = _$PrimaryInitialNavigatorState;
}

/// @nodoc
abstract class $AuthorizedInitialNavigatorStateCopyWith<$Res> {
  factory $AuthorizedInitialNavigatorStateCopyWith(
          AuthorizedInitialNavigatorState value,
          $Res Function(AuthorizedInitialNavigatorState) then) =
      _$AuthorizedInitialNavigatorStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$AuthorizedInitialNavigatorStateCopyWithImpl<$Res>
    extends _$InitialNavigatorStateCopyWithImpl<$Res>
    implements $AuthorizedInitialNavigatorStateCopyWith<$Res> {
  _$AuthorizedInitialNavigatorStateCopyWithImpl(
      AuthorizedInitialNavigatorState _value,
      $Res Function(AuthorizedInitialNavigatorState) _then)
      : super(_value, (v) => _then(v as AuthorizedInitialNavigatorState));

  @override
  AuthorizedInitialNavigatorState get _value =>
      super._value as AuthorizedInitialNavigatorState;
}

/// @nodoc
class _$AuthorizedInitialNavigatorState
    extends AuthorizedInitialNavigatorState {
  const _$AuthorizedInitialNavigatorState() : super._();

  @override
  String toString() {
    return 'InitialNavigatorState.authorized()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is AuthorizedInitialNavigatorState);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult primary(),
    @required TResult authorized(),
    @required TResult unAuthorized(),
  }) {
    assert(primary != null);
    assert(authorized != null);
    assert(unAuthorized != null);
    return authorized();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult primary(),
    TResult authorized(),
    TResult unAuthorized(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (authorized != null) {
      return authorized();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult primary(PrimaryInitialNavigatorState value),
    @required TResult authorized(AuthorizedInitialNavigatorState value),
    @required TResult unAuthorized(UnAuthorizedInitialNavigatorState value),
  }) {
    assert(primary != null);
    assert(authorized != null);
    assert(unAuthorized != null);
    return authorized(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult primary(PrimaryInitialNavigatorState value),
    TResult authorized(AuthorizedInitialNavigatorState value),
    TResult unAuthorized(UnAuthorizedInitialNavigatorState value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (authorized != null) {
      return authorized(this);
    }
    return orElse();
  }
}

abstract class AuthorizedInitialNavigatorState extends InitialNavigatorState {
  const AuthorizedInitialNavigatorState._() : super._();
  const factory AuthorizedInitialNavigatorState() =
      _$AuthorizedInitialNavigatorState;
}

/// @nodoc
abstract class $UnAuthorizedInitialNavigatorStateCopyWith<$Res> {
  factory $UnAuthorizedInitialNavigatorStateCopyWith(
          UnAuthorizedInitialNavigatorState value,
          $Res Function(UnAuthorizedInitialNavigatorState) then) =
      _$UnAuthorizedInitialNavigatorStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$UnAuthorizedInitialNavigatorStateCopyWithImpl<$Res>
    extends _$InitialNavigatorStateCopyWithImpl<$Res>
    implements $UnAuthorizedInitialNavigatorStateCopyWith<$Res> {
  _$UnAuthorizedInitialNavigatorStateCopyWithImpl(
      UnAuthorizedInitialNavigatorState _value,
      $Res Function(UnAuthorizedInitialNavigatorState) _then)
      : super(_value, (v) => _then(v as UnAuthorizedInitialNavigatorState));

  @override
  UnAuthorizedInitialNavigatorState get _value =>
      super._value as UnAuthorizedInitialNavigatorState;
}

/// @nodoc
class _$UnAuthorizedInitialNavigatorState
    extends UnAuthorizedInitialNavigatorState {
  const _$UnAuthorizedInitialNavigatorState() : super._();

  @override
  String toString() {
    return 'InitialNavigatorState.unAuthorized()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is UnAuthorizedInitialNavigatorState);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult primary(),
    @required TResult authorized(),
    @required TResult unAuthorized(),
  }) {
    assert(primary != null);
    assert(authorized != null);
    assert(unAuthorized != null);
    return unAuthorized();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult primary(),
    TResult authorized(),
    TResult unAuthorized(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (unAuthorized != null) {
      return unAuthorized();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult primary(PrimaryInitialNavigatorState value),
    @required TResult authorized(AuthorizedInitialNavigatorState value),
    @required TResult unAuthorized(UnAuthorizedInitialNavigatorState value),
  }) {
    assert(primary != null);
    assert(authorized != null);
    assert(unAuthorized != null);
    return unAuthorized(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult primary(PrimaryInitialNavigatorState value),
    TResult authorized(AuthorizedInitialNavigatorState value),
    TResult unAuthorized(UnAuthorizedInitialNavigatorState value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (unAuthorized != null) {
      return unAuthorized(this);
    }
    return orElse();
  }
}

abstract class UnAuthorizedInitialNavigatorState extends InitialNavigatorState {
  const UnAuthorizedInitialNavigatorState._() : super._();
  const factory UnAuthorizedInitialNavigatorState() =
      _$UnAuthorizedInitialNavigatorState;
}
